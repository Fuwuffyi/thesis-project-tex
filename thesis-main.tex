\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[utf8]{inputenc}
\usepackage{disi-thesis}
\usepackage{code-lstlistings}
\usepackage{notes}
\usepackage{shortcuts}
\usepackage{xcolor}
% \usepackage{acronym}

% Definition of acronyms
% \acrodef{API}{Application Programming Interface}
% \acrodef{PBR}{Physically Based Rendering}
% \acrodef{CPU}{Central Processing Unit}
% \acrodef{GPU}{Graphical Processing Unit}

%% Copyright (c) 2020-2021 Benno Bielmeier
%% SPDX-License-Identifier: MIT
%%
%% GLSL definition
%%
\lstdefinelanguage{GLSL}
{
   morekeywords={
      false,true,break,case,continue,default,discard,do,else,for,if,return,switch,while,void,bool,int,uint,float,double,
      vec2,vec3,vec4,dvec2,dvec3,dvec4,bvec2,bvec3,bvec4,ivec2,ivec3,ivec4,uvec2,uvec3,uvec4,mat2,mat3,mat4,mat2x2,mat2x3,
      mat2x4,mat3x2,mat3x3,mat3x4,mat4x2,mat4x3,mat4x4,dmat2,dmat3,dmat4,dmat2x2,dmat2x3,dmat2x4,dmat3x2,dmat3x3,dmat3x4,
      dmat4x2,dmat4x3,dmat4x4,sampler1D,sampler2D,sampler3D,struct,abs,acos,all,any,asin,atan,ceil,clamp,cos,cross,
      degrees,dFdx,dFdy,distance,dot,equal,exp,exp2,faceforward,floor,fract,ftransform,inversesqrt,length,log,log2,
      matrixCompMult,max,min,mix,mod,normalize,pow,radians,reflect,refract,transpose
   },
   sensitive=true,
   morecomment=[s]{/*}{*/},
   morecomment=[l]//,
   morestring=[b]",
   morestring=[b]',
   moredelim=*[directive]\#,
   moredirectives={define,defined,elif,else,if,ifdef,endif,line,error,ifndef,include,pragma,undef,warning,extension,version}
}

\school{\unibo}
\programme{Corso di Laurea in Ingegneria e Scienze Informatiche}
\title{OpenGL e Vulkan: un caso di studio}
\author{Palazzini Luca}
\date{\today}
\subject{Computer Graphics}
\supervisor{Prof.ssa Damiana Lazzaro}
\session{I}
\academicyear{2024-2025}

\mainlinespacing{1.241}

\begin{document}

\frontmatter\frontispiece

\begin{abstract}
Questo lavoro presenta la progettazione e implementazione di un motore di rendering modulare in C++23, capace di operare
sia con OpenGL 4.6 sia con Vulkan 1.4, finalizzato a uno studio comparativo rigoroso delle prestazioni tra le due
API in scenari complessi di grafica 3D. Il motore implementa una pipeline di \emph{deferred rendering}, supporta
materiali PBR basati sul modello Cook-Torrance, luci direzionali, puntuali e spot, sistemi di particelle instanziate
e strumenti di debug visuale (gizmo per luci e bounding). L’architettura a componenti, con separazione netta tra scena,
risorse e renderer, consente di cambiare backend senza modificare la logica applicativa, garantendo condizioni di test
identiche. Lo studio si concentra sull’impatto del multithreading in Vulkan rispetto al modello single-thread di OpenGL,
misurando tempo medio per frame, frame rate, occupazione di CPU e GPU e overhead del driver. Vulkan evidenzia vantaggi
significativi in scenari con molti oggetti e luci, grazie alla registrazione parallela dei command buffer, all’utilizzo
di descriptor set e pipeline layout ottimizzati, e al controllo esplicito della memoria GPU. OpenGL, al contrario,
rimane vincolato dal single-threading e dalla gestione automatica delle risorse, mostrando saturazione del driver e
overhead nei draw call massivi. Questo progetto fornisce un caso di studio completo, evidenziando differenze architetturali,
scaling multi-core, gestione esplicita della pipeline e costi reali delle API moderne, offrendo indicazioni concrete su
efficienza, prevedibilità delle prestazioni e best practice per lo sviluppo di motori grafici moderni.
\end{abstract}

% TODO: Write dedication (optional)
\begin{dedication}
   Optional. Max a few lines.
\end{dedication}

% Table of contents
\tableofcontents
\listoffigures
\lstlistoflistings

% Main content
\mainmatter

% TODO: Check image/listing/table references
% TODO: Improve chapter 4?

%----------------------------------------------------------------------------------------
\chapterWithoutNumber{Introduzione}
\label{chap:introduzione}
%----------------------------------------------------------------------------------------

Negli ultimi anni, il campo della grafica computazionale ha visto un'evoluzione significativa delle \emph{Graphics APIs}
verso modelli di programmazione più vicini all'hardware e orientati alle alte prestazioni.
Il contributo principale di questo lavoro consiste nello sviluppo di un motore di rendering modulare che consente
un confronto controllato tra backend OpenGL e Vulkan, con l'obiettivo di analizzarne le differenze prestazionali e architetturali.
Il confronto si concentra in particolare sull'impatto del multithreading in Vulkan rispetto al modello single-thread
tipico di OpenGL, analizzando come la differente gestione della pipeline grafica influisca sulle prestazioni complessive.
L'obiettivo principale del lavoro è progettare e sviluppare un motore di rendering scritto in \emph{C++23},
in grado di operare sia con OpenGL 4.6 sia con Vulkan 1.4. \\
Il motore implementa un approccio di tipo \emph{deferred rendering}, supporta materiali Physically Based Rendering (PBR),
luci direzionali, puntuali e spot, e include ulteriori passaggi di rendering per particelle e oggetti di debug.
L'architettura segue un paradigma orientato agli oggetti, integrando librerie e framework comuni.
L'obiettivo sperimentale è valutare, a parità di contenuto e condizioni di rendering, l'efficienza delle due API
in termini di:
\begin{itemize}
   \item tempo medio per frame e frame rate;
   \item utilizzo della CPU e della GPU.
\end{itemize}
Il progetto è stato sviluppato con un approccio incrementale, secondo cicli iterativi di implementazione e validazione.
Il motore adotta una struttura modulare che separa la logica di rendering dalla gestione della scena, così da consentire
il confronto diretto tra i due backend.
I test prestazionali sono stati condotti su una scena principale: la cattedrale di Sponza~\cite{sponza_original,sponza_intel2022},
utilizzando diversi hardware, variando numero di luci e \emph{particle systems}, per misurare in modo oggettivo i benefici derivati
dal parallelismo offerto da Vulkan.

\paragraph{Struttura della tesi}
La struttura della tesi è la seguente:
\begin{itemize}
   \item Il \textbf{Capitolo 1} introduce i concetti fondamentali relativi al rendering, alle API grafiche moderne e alle tecniche PBR e deferred rendering;
   \item Il \textbf{Capitolo 2} analizza i requisiti del progetto e le scelte progettuali alla base del motore sviluppato;
   \item Il \textbf{Capitolo 3} descrive l'architettura del sistema e i principali componenti software;
   \item Il \textbf{Capitolo 4} illustra l'implementazione e mostra esempi di codice e schermate del motore in funzione;
   \item Il \textbf{Capitolo 5} presenta la valutazione sperimentale, i risultati delle misure e la loro analisi critica.
\end{itemize}

%----------------------------------------------------------------------------------------
\chapter{Fondamenti Teorici}
\label{chap:fondamenti-teorici}
%----------------------------------------------------------------------------------------
\noindent
Questo capitolo fornisce il quadro teorico necessario alla comprensione del lavoro svolto.
Vengono introdotti i concetti fondamentali relativi alla pipeline di rendering,
analizzando le differenze tra i principali approcci utilizzati nei motori grafici moderni,
in particolare il \emph{forward rendering} e il \emph{deferred rendering}.
Segue un approfondimento sui principi del \emph{Physically Based Rendering} (PBR),
che costituisce la base fisica dei modelli di illuminazione implementati nel motore sviluppato.
Infine, vengono presentate le due API grafiche oggetto dello studio, OpenGL e Vulkan,
e le principali librerie di supporto utilizzate nel progetto.
L'obiettivo del capitolo è fornire al lettore una visione d'insieme dei fondamenti teorici e tecnologici
su cui si basa l'intero lavoro sperimentale.

\section{Pipeline di Rendering}
Una pipeline di rendering è una sequenza di fasi che trasforma la rappresentazione tridimensionale di una scena in
un'immagine bidimensionale visualizzabile sullo schermo. Ogni fase elabora i dati provenienti dalla precedente,
passando progressivamente da una descrizione geometrica ad una descrizione visiva.
Nelle API moderne come OpenGL e Vulkan, la pipeline grafica è composta da una serie di stadi programmabili:
elaborazione dei vertici, assemblaggio dei primitivi, rasterizzazione, shading dei frammenti e scrittura nel
\emph{framebuffer} (Fig.\ref{fig:rendering-pipeline-overview}).
Nello stadio di elaborazione dei vertici, ogni punto della geometria viene trasformato nello spazio di proiezione,
mentre nello stadio dei frammenti viene calcolato il colore finale di ciascun pixel tenendo conto della luce e delle
proprietà del materiale.
\begin{figure}[htbp]
   \centering
   \includegraphics[width=.8\linewidth]{figures/rendering_pipeline_overview.png}
   \caption{Stadi di una pipeline di rendering.}
   \label{fig:rendering-pipeline-overview}
\end{figure}
Il processo di rendering di una scena tridimensionale può essere realizzato attraverso approcci differenti,
ognuno con vantaggi e limiti specifici. I due modelli principali sono il \emph{forward rendering} e il
\emph{deferred rendering}, che differiscono per il modo in cui gestiscono il calcolo dell'illuminazione e la
composizione finale dell'immagine.
Il rendering di una scena tridimensionale trasforma modelli matematici di oggetti e luci in un'immagine bidimensionale,
seguendo diverse pipeline, ciascuna con specifici vantaggi e limiti.
Nel \emph{forward rendering}, ogni oggetto della scena viene renderizzato direttamente con tutte le luci che lo influenzano.
Durante il passaggio di rendering, per ogni frammento vengono calcolati il colore finale e il contributo luminoso
di ciascuna sorgente, con il risultato che il numero di calcoli cresce proporzionalmente al numero di luci.
Questo metodo è relativamente semplice da implementare, ma può diventare inefficiente in scene complesse, dove molte
luci influenzano simultaneamente la stessa area. Tuttavia, rimane ancora oggi una soluzione adatta a contesti con un
numero limitato di luci dinamiche o in applicazioni dove la compatibilità e la semplicità di implementazione sono prioritarie.
Il \emph{deferred rendering}, invece, suddivide il processo di rendering in più passaggi. Nel primo, chiamato
\emph{geometry pass}, vengono memorizzate nei cosiddetti \emph{G-buffer} le informazioni geometriche necessarie,
come la posizione dei punti \(\mathbf{P}\), le normali delle superfici \(\mathbf{N}\) e le proprietà dei materiali
(albedo \(A\), roughness \(r\), metallic \(m\), normal map \(\mathbf{N}\), ambient occlusion AO).
\begin{figure}[htbp]
   \centering
   \includegraphics[width=.8\linewidth]{figures/g_buffer_example.png}
   \caption{Esempio di G-buffer in una pipeline di deferred rendering da \cite{learnopengl}.}
   \label{fig:g-buffer-example}
\end{figure}
Nel secondo passaggio, denominato \emph{lighting pass}, l'illuminazione viene calcolata utilizzando i dati salvati
nei buffer (Fig.\ref{fig:g-buffer-example}), evitando di dover eseguire nuovamente le trasformazioni geometriche per ogni
luce. L'equazione generale per il colore finale di un frammento è:
\begin{align*}
C_{\text{final}} = \sum_{i=1}^{N_\text{luci}} L_i(\mathbf{P}, \mathbf{N}) \cdot f_r(\mathbf{V}, \mathbf{L}_i, \mathbf{N})
\end{align*}
dove \(L_i\) è il contributo della luce i-esima e \(f_r\) è la funzione di BRDF utilizzata per il materiale del frammento.
Questo approccio permette di gestire un numero elevato di luci in modo più efficiente, rendendolo particolarmente
indicato per applicazioni moderne e motori di gioco con scenari complessi (Fig.\ref{fig:deferred-pipeline-example}).
\begin{figure}[htbp]
   \centering
   \includegraphics[width=.8\linewidth]{figures/deferred_pipeline_example.png}
   \caption{Schema generale della pipeline di deferred rendering da \cite{learnopengl}.}
   \label{fig:deferred-pipeline-example}
\end{figure}
Il motore sviluppato per questa tesi adotta una pipeline di tipo \emph{deferred}, in quanto offre una base più
flessibile per l'analisi delle prestazioni e per l'integrazione di tecniche di illuminazione avanzate.
Le tecniche di illuminazione descritte nelle sezioni successive, in particolare il Physically Based Rendering,
si integrano con tale pipeline per ottenere una resa fisicamente plausibile dei materiali.

\section{Physically Based Rendering (PBR)}
Il \emph{Physically Based Rendering} (PBR) fornisce un modello matematico per simulare il comportamento reale
della luce quando interagisce con una superficie. Si basa sulla \emph{Legge della Conservazione dell'Energia}
e sull'ipotesi che la luce riflessa o assorbita da un materiale dipenda dalle proprietà fisiche microscopiche
della sua superficie.

\subsection*{Equazione di Rendering}
L'illuminazione totale uscente da un punto $p$ in direzione di vista $\omega_o$ è data da:
\begin{align*}
L_o(p,\omega_o) = \int_{\Omega} f_r(p,\omega_i,\omega_o) \, L_i(p,\omega_i)\, (\mathbf{n}\cdot\omega_i)\,d\omega_i
\end{align*}
\noindent
Qui:
\begin{itemize}
    \item $L_o$ è la radiance uscente, cioè la luce che lascia la superficie verso l'osservatore;
    \item $L_i$ è la radiance incidente, cioè la luce che arriva sulla superficie da una direzione $\omega_i$;
    \item $f_r$ è la funzione di riflettanza bidirezionale (BRDF), che definisce come la luce viene riflessa in base alla direzione incidente e a quella di uscita;
    \item $(\mathbf{n}\cdot\omega_i)$ rappresenta il fattore geometrico di Lambert, cioè quanto la luce è "efficace" in base all'angolo di incidenza.
\end{itemize}
In parole semplici, questa equazione somma tutta la luce incidente sulla superficie pesata da come il materiale
la riflette verso l'occhio dell'osservatore.

\subsection*{Modello Cook-Torrance}
Il modello più diffuso nel PBR è il \emph{Cook-Torrance microfacet model}, che rappresenta la superficie come un insieme
di microfacets inclinati. Ogni microfacet riflette la luce secondo la legge di Fresnel, e la distribuzione delle
loro inclinazioni determina l'aspetto speculare della superficie.
La BRDF si scrive come:
\begin{align*}
f_r(\omega_i,\omega_o) = k_d \frac{A}{\pi} +
k_s \frac{D(\mathbf{n},\mathbf{h})\,F(\omega_o,\mathbf{h})\,G(\omega_i,\omega_o,\mathbf{n})}
{4(\mathbf{n}\cdot\omega_i)(\mathbf{n}\cdot\omega_o)}
\end{align*}
\noindent
Qui il primo termine $k_d \frac{A}{\pi}$ rappresenta la riflessione diffusa lambertiana, responsabile della componente di
colore percepita indipendentemente dall'angolo di vista.
Il secondo termine descrive la riflessione speculare dovuta alla micro-geometria della superficie. In particolare:
\begin{itemize}
    \item $D(\mathbf{n},\mathbf{h})$ è la \emph{Normal Distribution Function} (NDF), che definisce la distribuzione statistica
    dell'orientazione dei microfacets. Controlla la concentrazione del riflesso speculare.
    \item $F(\omega_o,\mathbf{h})$ è il termine di \emph{Fresnel}, che determina la quantità di luce riflessa in funzione
    dell'angolo tra osservatore e microfacet. Governa la crescita del riflesso a incidenti radenti.
    \item $G(\omega_i,\omega_o,\mathbf{n})$ è il termine di \emph{geometrical attenuation}, che modella l'auto-occlusione:
    microfacets possono bloccare la luce incidente o riflessa.
\end{itemize}
Il vettore metà $\mathbf{h} = \frac{\omega_i+\omega_o}{\|\omega_i+\omega_o\|}$ rappresenta la direzione intermedia
tra luce e osservatore, usata per calcolare la riflessione speculare.

\subsection*{Normal Distribution Function (NDF)}
$D(\mathbf{n},\mathbf{h})$ descrive la densità dei microfacets orientati verso la direzione $\mathbf{h}$.  
Un modello comune è il GGX (Trowbridge-Reitz):
\begin{align*}
D_{\text{GGX}}(\mathbf{n},\mathbf{h},r) =
\frac{r^2}
{\pi \big[(\mathbf{n}\cdot\mathbf{h})^2(r^2-1)+1\big]^2}
\end{align*}
\noindent
In pratica, $r$ (roughness) controlla quanto "liscia" o "ruvida" appare la superficie: valori bassi concentrano gli
highlight speculari, valori alti li diffondono e ammorbidiscono.

\subsection*{Fresnel Term}
$F(\omega_o,\mathbf{h})$ rappresenta la variazione dell'intensità della riflessione in base all'angolo di incidenza.
Il modello di Schlick fornisce una buona approssimazione:
\begin{align*}
F(\omega_o,\mathbf{h}) = F_0 + (1 - F_0)(1 - \omega_o\cdot\mathbf{h})^5
\end{align*}
\noindent
Qui, $F_0$ è la riflettanza a incidenza normale (tipicamente 0.04 per dielettrici, uguale al colore del
metallo per metallici).
Questo termine genera l'effetto noto in grafica come "specular highlight più intenso ai bordi".

\subsection*{Geometric Term}
$G(\omega_i,\omega_o,\mathbf{n})$ tiene conto dell'auto-occlusione dei microfacets, cioè che alcuni microfacets
possono bloccare la luce di altri:
\begin{align*}
G(\omega_i,\omega_o,\mathbf{n}) = G_1(\omega_i,\mathbf{n}) \, G_1(\omega_o,\mathbf{n})
\end{align*}
\begin{align*}
G_1(\omega,\mathbf{n}) =
\frac{2(\mathbf{n}\cdot\omega)}
{(\mathbf{n}\cdot\omega) + \sqrt{r^2 + (1-r^2)(\mathbf{n}\cdot\omega)^2}}
\end{align*}
In parole semplici, quando la luce colpisce la superficie a un angolo basso o quando la vista è laterale, parte
della luce viene "nascosta" dai microfacets, riducendo la riflessione percepita (Fig.\ref{fig:pbr-material-render}).

\subsection*{Equazione completa di illuminazione}
Combinando i termini precedenti, l'illuminazione riflessa diventa:
\begin{align*}
L_o(p,\omega_o) =
\int_{\Omega}
\left(
k_d\frac{A}{\pi} +
\frac{D\,F\,G}
{4(\omega_o\cdot\mathbf{n})(\omega_i\cdot\mathbf{n})}
\right)
L_i(p,\omega_i)\,
(\mathbf{n}\cdot\omega_i)\,d\omega_i
\end{align*}
\noindent
Questa integrazione viene valutata in modo approssimato nel rendering in tempo reale tramite
\emph{environment maps}, \emph{prefiltered radiance} e \emph{BRDF lookup tables}.
In pratica, ogni termine della formula corrisponde a un effetto visivo:
\begin{itemize}
    \item $k_d A/\pi$ → colore diffuso del materiale;
    \item $D$ → forma e ampiezza dello speculare;
    \item $F$ → intensità speculare in base all'angolo di visuale;
    \item $G$ → riduzione della luce dovuta all'auto-occlusione dei microfacets.
\end{itemize}
\begin{figure}[htbp]
   \centering
   \includegraphics[width=.8\linewidth]{figures/pbr_material_render.png}
   \caption{Array di 10$\times$10 cubi che mostra l'effetto della variazione di roughness (righe) e metalness
      (colonne) sui materiali PBR.}
   \label{fig:pbr-material-render}
\end{figure}
\noindent
L'aumento di roughness disperde la luce, generando highlight più ampi e opachi (Fig.\ref{fig:pbr-material-example});
l'aumento del valore metallic incrementa la riflessione speculare e riduce la componente diffusa.
Queste relazioni rendono il PBR un modello coerente e fisicamente plausibile per la rappresentazione
di materiali in ambienti virtuali.
\begin{figure}[htbp]
   \centering
   \includegraphics[width=.8\linewidth]{figures/pbr_material_example.png}
   \caption{Esempio di materiale PBR da \cite{learnopengl}.}
   \label{fig:pbr-material-example}
\end{figure}

\section{Graphics API: OpenGL and Vulkan}
OpenGL e Vulkan rappresentano due approcci concettualmente diversi allo sviluppo di applicazioni grafiche. \\
OpenGL è un'API di livello alto che semplifica notevolmente la gestione della pipeline grafica: gran parte del lavoro
legato alla sincronizzazione delle risorse, alla gestione della memoria e alla compilazione dei comandi GPU è affidato
al driver. Questo approccio riduce la complessità dello sviluppo, consentendo di ottenere rapidamente risultati visivi,
ma limita il controllo del programmatore sulle prestazioni, soprattutto in scenari con molte luci e geometrie complesse.
OpenGL opera principalmente in modalità single-thread, affidando al driver l'organizzazione dei comandi su GPU, il che può
generare overhead significativi in applicazioni moderne e multithreaded. \\
Vulkan, al contrario, offre un modello di programmazione a basso livello, dove il programmatore ha il controllo diretto
sulla memoria, sui comandi e sulla sincronizzazione. La pipeline Vulkan richiede la definizione esplicita di tutti i
passaggi di rendering attraverso strutture come \texttt{Render Pass} e \texttt{Command Buffers}, e la gestione della 
sincronizzazione è completamente esplicita mediante \texttt{Semaphore} e \texttt{Fence}. Questo approccio riduce
l'overhead del driver e permette di sfruttare pienamente il multithreading della CPU, rendendo più efficienti
le applicazioni che devono gestire grandi quantità di oggetti e luci in scena. Allo stesso tempo, Vulkan richiede
una conoscenza approfondita dell'architettura hardware e della gestione delle risorse, aumentando la complessità
dello sviluppo rispetto a OpenGL.

\section{Librerie e Strumenti}
Il motore sviluppato utilizza un insieme di librerie open source per la gestione dell'infrastruttura di rendering
e delle funzionalità.
La combinazione di queste librerie ha permesso di ridurre il tempo di sviluppo e concentrarsi sulle differenze
architetturali tra OpenGL e Vulkan.
\begin{itemize}
   \item \textbf{GLFW}: fornisce un'interfaccia multipiattaforma per la creazione di finestre e la gestione dell'input.
      È utilizzata sia per il backend OpenGL che Vulkan;
   \item \textbf{GLAD}: gestisce il caricamento dinamico delle estensioni OpenGL;
   \item \textbf{Vulkan Memory Allocator (VMA)} e \textbf{vk-bootstrap}: semplificano la configurazione e la gestione della memoria
      Vulkan, riducendo la complessità di codice di inizializzazione;
   \item \textbf{glm}: libreria matematica per operazioni su vettori, matrici e trasformazioni 3D;
   \item \textbf{ImGui}: libreria per la costruzione di interfacce grafiche di debug e monitoraggio delle prestazioni in tempo reale;
   \item \textbf{stb\_image}: caricamento di texture in vari formati;
   \item \textbf{ASSIMP}: parsing dei modelli 3D in formato \texttt{.obj} e \texttt{.fbx}.
\end{itemize}

\section{Lavori Correlati}
Diversi studi e progetti hanno analizzato il confronto tra OpenGL e Vulkan, evidenziando vantaggi significativi di
Vulkan in termini di efficienza e parallelismo.
Il \emph{Khronos Group}, nelle specifiche di rilascio e nei documenti ufficiali, evidenzia come Vulkan sia progettata per
minimizzare l'overhead del driver e fornire prestazioni più prevedibili grazie a un controllo esplicito delle risorse e
dell'esecuzione dei comandi \cite{khronos_vulkan_spec,vulkan_overview,google_vulkan_lowoverhead}.
Sul fronte applicativo, motori come \emph{Unreal Engine 5} e \emph{Unity} hanno introdotto backend Vulkan per
ottimizzare la scalabilità su dispositivi moderni, mantenendo al contempo compatibilità con OpenGL su piattaforme legacy.

%----------------------------------------------------------------------------------------
\chapter{Requisiti ed Analisi}
\label{chap:analisi}
%----------------------------------------------------------------------------------------
\noindent
In questo capitolo vengono definiti i requisiti funzionali e non funzionali del motore di rendering 
e analizzate le motivazioni alla base delle scelte progettuali.
L'obiettivo è stabilire un quadro metodologico chiaro che guidi la progettazione e l'implementazione del sistema,
tenendo conto dei vincoli tecnici imposti dalle API e dall'hardware.
Lo sviluppo del motore di rendering oggetto di questo elaborato nasce con l'obiettivo di creare una piattaforma
sperimentale che permetta di confrontare in modo diretto le prestazioni e le differenze architetturali tra
OpenGL e Vulkan.
Dopo aver descritto le funzionalità attese e le caratteristiche qualitative del software,
si discutono i principali vincoli di progetto e le librerie adottate.
Il capitolo si conclude illustrando la strategia di valutazione delle prestazioni,
che costituisce la base per l'analisi comparativa tra OpenGL e Vulkan presentata nei capitoli successivi.
Le analisi svolte guidano le scelte architetturali descritte nei capitoli successivi.

\section{Requisiti funzionali}
Dal punto di vista funzionale, il motore deve essere in grado di gestire l'intero processo di rendering di una
scena tridimensionale complessa, fornendo un'infrastruttura flessibile per la sperimentazione con entrambe le API.
Il primo requisito riguarda la possibilità di selezionare, in fase di avvio, quale backend utilizzare tra OpenGL e
Vulkan. Tale scelta consente di confrontare le due pipeline in modo trasparente, mantenendo invariata la struttura
logica del motore e la scena visualizzata. \\
Il motore deve poi garantire la gestione completa delle risorse grafiche, tra cui modelli tridimensionali, texture e
shader. A tal fine, è stato previsto un sistema di caricamento e caching che consente di ridurre le operazioni ridondanti
e di ottimizzare la condivisione della memoria tra CPU e GPU. Il rendering della scena è realizzato attraverso una
pipeline di tipo \emph{deferred}, scelta per la sua maggiore efficienza nella gestione di un elevato numero di luci
dinamiche. \\
Un ulteriore requisito fondamentale riguarda il supporto al \emph{Physically Based Rendering (PBR)}, che permette
di ottenere una resa realistica dei materiali basandosi su parametri fisici. Il sistema deve inoltre consentire
l'utilizzo di differenti tipologie di luci con parametri configurabili dall'interfaccia di debug. \\
Nel backend Vulkan, il motore deve supportare la generazione multithread dei \texttt{command buffer}, così da sfruttare
in modo più efficiente i core della CPU. Questa caratteristica è essenziale per valutare i benefici del parallelismo
offerto da Vulkan rispetto al modello single-thread di OpenGL. Infine, il motore deve includere una telecamera
controllabile in tempo reale e un'interfaccia grafica basata su ImGui per la visualizzazione delle statistiche di
esecuzione e dei parametri di scena.

\section{Requisiti non-funzionali}
Oltre alle funzionalità previste, il progetto deve rispettare una serie di requisiti non funzionali che ne
determinano la qualità complessiva. L'aspetto più rilevante è quello prestazionale: il motore deve essere in grado
di mantenere un frame rate stabile e prevedibile, anche in presenza di scene complesse. L'efficienza del codice e
la riduzione dell'overhead di CPU sono obiettivi primari, soprattutto nella versione Vulkan. \\
Un altro requisito riguarda la portabilità. Il sistema deve poter essere compilato ed eseguito sia su Windows che su
Linux, senza modifiche sostanziali al codice sorgente. Questo ha orientato la scelta di librerie multipiattaforma
come GLFW per la gestione delle finestre e dell'input, e glm per le operazioni matematiche tridimensionali.
La manutenibilità è stata garantita attraverso una struttura modulare del codice, che separa nettamente la logica di
rendering dalle altre componenti, come la gestione delle risorse o la GUI. Tale separazione consente di estendere il
motore in futuro con nuove tecniche di shading o ulteriori passaggi di rendering, senza introdurre dipendenze
circolari o modifiche invasive. \\
L'affidabilità rappresenta un ulteriore requisito importante. In particolare, è necessario assicurare che le risorse
allocate sulla GPU vengano correttamente rilasciate al termine dell'esecuzione, prevenendo perdite di memoria o crash.
La presenza dell'interfaccia di debug consente inoltre di monitorare in tempo reale l'utilizzo delle risorse e il
tempo di esecuzione dei frame, migliorando la tracciabilità e la diagnosi dei colli di bottiglia.

\section{Vincoli di progetto}
Il progetto è stato sviluppato nel rispetto di alcuni vincoli tecnici legati sia alla piattaforma hardware sia alle
librerie disponibili. Il linguaggio scelto è \textbf{C++23}, che offre un buon compromesso tra efficienza,
astrazione e modernità, consentendo l'utilizzo di costrutti avanzati come le \emph{smart pointer} e le
\emph{range-based loops}. Le API grafiche target sono OpenGL 4.6 e Vulkan 1.4, in modo da garantire compatibilità
con la maggior parte delle GPU moderne. \\
Dal punto di vista hardware, i test sono stati condotti su molteplici configurazioni dotata di processore multi-core e GPU
di fascia medio-alta compatibile con le specifiche Vulkan. Le prestazioni sono state misurate su tutti gli hardware
con entrambi gli API e con scene che variano in quantità di luci e effetti particellari. \\
Il motore si appoggia a un insieme di librerie open source per ridurre il tempo di sviluppo e migliorare la stabilità
del codice. Tra queste rientrano GLFW per la creazione delle finestre, GLAD per il caricamento dinamico delle estensioni
OpenGL, Vulkan Memory Allocator e vk-bootstrap per la gestione semplificata delle risorse Vulkan, ImGui per
l'interfaccia di debug, glm per le operazioni matematiche e ASSIMP per il caricamento dei modelli tridimensionali.
Il sistema di build è basato su CMake, scelto per la sua compatibilità multipiattaforma e l'integrazione con ambienti
di sviluppo moderni. \\
Per delimitare il campo di studio, sono stati esclusi elementi non essenziali all'obiettivo sperimentale, come il
ray tracing, le ombre dinamiche avanzate o il supporto a dispositivi mobili. La ricerca si concentra esclusivamente
sulle differenze di prestazioni e di gestione delle risorse tra le due API, in un contesto di rendering differito
tradizionale.

\section{Strategia di Valutazione}
La valutazione delle prestazioni rappresenta una parte fondamentale di questo lavoro. La strategia adottata prevede
una serie di test ripetibili e controllati, condotti su una scena di riferimento comune: la cattedrale di
Sponza~\cite{sponza_original,sponza_intel2022}, ampiamente utilizzata come benchmark nella letteratura di grafica
computazionale. I test vengono eseguiti con configurazioni identiche per i due backend, variando il numero di luci,
la complessità della scena e il livello di parallelismo della CPU.
Le metriche considerate includono il tempo medio per frame, il frame rate e l'utilizzo medio della CPU e della GPU.
I dati vengono raccolti tramite un sistema di monitoraggio integrato nell'interfaccia di debug, che consente la
registrazione automatica dei risultati per l'analisi successiva.
Ciascun test viene ripetuto più volte per ridurre l'impatto di fattori esterni, come i processi di sistema o
l'oscillazione della frequenza della GPU. I risultati vengono poi confrontati e discussi nel
Capitolo~\ref{chap:valutazione}, dove vengono analizzate le differenze di comportamento tra OpenGL e Vulkan in termini
di efficienza, scalabilità e prevedibilità delle prestazioni.

%----------------------------------------------------------------------------------------
\chapter{Progettazione e Architettura del Sistema}
\label{chap:design}
%----------------------------------------------------------------------------------------
\noindent
Il presente capitolo descrive l'architettura del motore di rendering sviluppato per la tesi, con particolare attenzione
all'organizzazione modulare, all'interazione tra componenti e alla gestione dei backend OpenGL e Vulkan. L'obiettivo
principale della progettazione è stato garantire flessibilità, portabilità e manutenibilità, permettendo al contempo un
confronto controllato delle prestazioni tra le due API.

\section{Panoramica del Sistema}
Il motore di rendering è strutturato secondo un approccio modulare che separa nettamente la gestione della scena dalla
logica di rendering e dalla gestione delle risorse. \\
La scena è organizzata tramite un \texttt{Scene Manager}, che contiene nodi (\texttt{Node}) e componenti specifici come
\texttt{TransformComponent}, \texttt{LightComponent} e \texttt{ParticleSystemComponent}. Ogni nodo può avere figli,
permettendo di costruire gerarchie complesse e di propagare trasformazioni e proprietà luminose lungo la scena. \\
Il modulo di rendering interagisce con i backend grafici attraverso l'interfaccia astratta \texttt{IRenderer}, che
definisce i metodi fondamentali per inizializzare le pipeline, eseguire il rendering dei frame e liberare le risorse. Le
implementazioni concrete \texttt{GLRenderer} e \texttt{VulkanRenderer} incapsulano la complessità specifica delle due
API, permettendo al resto del sistema di interagire in maniera unificata (Fig.\ref{fig:uml-activity-dynamic-backend}).
\begin{figure}[htbp]
    \centering
    \includegraphics[width=.95\linewidth]{figures/uml_activity_dynamic_backend.png}
    \caption{Selezione dinamica del backend grafico all'avvio.}
    \label{fig:uml-activity-dynamic-backend}
\end{figure}
La gestione delle risorse è centralizzata nel modulo \texttt{ResourceManager}, che si occupa di creare, caricare e
memorizzare mesh e texture, utilizzando factory specifiche per ciascun backend. Questa separazione consente di evitare
duplicazioni e facilita l’estensione del motore con nuovi tipi di risorse senza modificare la logica di rendering.
Il flusso di dati all'interno del motore parte dall'inserimento degli oggetti nella scena, passa attraverso i componenti
della scena, viene trasformato in strutture di dati compatibili con il backend selezionato e infine elaborato dalla
pipeline di rendering (Fig.\ref{fig:uml-scene-renderer}). Le metriche di performance sono raccolte dal modulo
\texttt{PerformanceLogger} e rese disponibili tramite \texttt{PerformanceGUI}, consentendo il monitoraggio in tempo reale.
\begin{figure}[htbp]
   \centering
   \includegraphics[width=.8\linewidth]{figures/uml_scene_renderer.png}
   \caption{Architettura generale del motore di rendering, con interazioni tra scena, renderer e gestione delle risorse.}
   \label{fig:uml-scene-renderer}
\end{figure}

\section{Progettazione Orientata agli Oggetti}
L'intero motore è stato progettato secondo il paradigma orientato agli oggetti, utilizzando classi astratte e
implementazioni concrete per separare la logica indipendente dall'API dalle componenti specifiche dei backend.
L'interfaccia \texttt{IRenderer} definisce il contratto per le operazioni di rendering, mentre \texttt{GLRenderer} e
\texttt{VulkanRenderer} forniscono le implementazioni dettagliate. Questa architettura consente di cambiare backend
senza modificare la struttura dei componenti della scena. \\
Le classi legate alla scena, tra cui \texttt{Node} e \texttt{TransformComponent}, sono progettate per propagare le trasformazioni
lungo gerarchie complesse, permettendo operazioni come parenting, rotazioni locali e scaling globale. \\
I materiali PBR sono gestiti tramite \texttt{MaterialTemplate} e \texttt{MaterialInstance}, separando i dati statici
del materiale dalle istanze specifiche applicate agli oggetti. Tale approccio permette di aggiornare in tempo reale
parametri come roughness, metalness e albedo, senza dover ricreare le risorse sulla GPU.

\section{Architettura del Motore di Rendering}
Il motore separa nettamente la logica di rendering dalla gestione della scena e delle risorse. Nel backend OpenGL,
la sincronizzazione e la gestione delle risorse sono affidate al driver, mentre in Vulkan ogni passaggio richiede controllo
esplicito di buffer, command pool e sincronizzazione tramite \texttt{Semaphore} e \texttt{Fence}. Questa separazione facilita
il confronto diretto tra i due backend senza alterare la logica della scena.
La pipeline di rendering è basata su deferred rendering. Il \emph{geometry pass} popola i G-buffer con informazioni sui
vertici e sui materiali. Il \emph{lighting pass} utilizza queste informazioni per calcolare l’illuminazione, evitando
ricalcoli geometrici e ottimizzando le operazioni per frammento. L'oct-encoding delle normali
riduce lo spazio occupato senza perdita significativa di precisione, mentre l’integrazione dei parametri PBR nei canali
texture ottimizza l’uso della memoria GPU.

\section{Componenti e Scene Graph}
Il motore integra un sistema a componenti, dove ogni nodo della scena può contenere uno o più componenti, tra cui
trasformazioni, luci e sistemi di particelle. Ogni frame, i componenti vengono aggiornati in sequenza, propagando le
trasformazioni e aggiornando gli stati di input e fisica. Questo approccio semplifica l’aggiunta di nuovi comportamenti
agli oggetti senza alterare la gerarchia principale della scena e consente di separare nettamente logica e rendering.

\section{Pipeline di Deferred Rendering}
Il motore utilizza una pipeline di \emph{deferred rendering} a due passaggi principali: il \emph{geometry pass},
che scrive nei G-buffer informazioni sui vertici e sulle proprietà dei materiali, e il \emph{lighting pass}, che calcola
l'illuminazione usando i dati memorizzati, ottimizzando il numero di operazioni per frammento.
La gestione dei G-buffer integra tecniche di \emph{oct-encoding} per le normali e memorizza roughness e metalness nei canali
non utilizzati delle texture, riducendo l'uso della memoria GPU.
Per il geometry pass, viene utilizzato uno shader GLSL dedicato che calcola le informazioni necessarie per ciascun
frammento della scena. Lo shader scrive nei G-buffer due texture principali (Fig.\ref{fig:g-buffer-textures}):
\begin{itemize}
    \item \texttt{gAlbedo}: canali RGB per il colore diffuso, canale A per l'AO.
    \item \texttt{gNormal}: normali codificate tramite un algoritmo di \emph{oct-encoding} nei canali RG, canale B per roughness, canale A per metallic.
\end{itemize}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=.8\linewidth]{figures/g_buffer_textures.png}
    \caption{Struttura del G-buffer con le texture e i canali utilizzati.}
    \label{fig:g-buffer-textures}
\end{figure}
La combinazione di queste tecniche garantisce un G-buffer compatto e performante, compatibile sia con OpenGL sia
con Vulkan, mantenendo alta la qualità visiva e minimizzando l'overhead di memoria e banda (Fig.\ref{fig:uml-activity-rendering}).
\begin{figure}[htbp]
    \centering
    \includegraphics[width=.8\linewidth]{figures/uml_activity_rendering.png}
    \caption{Flusso di rendering della scena attraverso il motore e i backend.}
    \label{fig:uml-activity-rendering}
\end{figure}
In Vulkan, la pipeline è progettata per sfruttare il multithreading della CPU. I \texttt{command buffer} sono generati
in parallelo su più thread, ciascuno occupandosi di un sottoinsieme di oggetti della scena, mentre la sincronizzazione
è gestita tramite \texttt{Semaphore} e \texttt{Fence}. Questo approccio riduce l’overhead del driver e consente di
scalare le prestazioni con il numero di core disponibili (Fig.\ref{fig:uml-activity-geometrythreading}). In OpenGL, invece, la pipeline rimane single-thread,
affidando la gestione dei comandi al driver, il che evidenzia le differenze prestazionali tra le due API in scenari complessi.
\begin{figure}[htbp]
    \centering
    \includegraphics[width=.8\linewidth]{figures/uml_activity_geometrythreading.png}
    \caption{Generazione di command buffer in parallelo.}
    \label{fig:uml-activity-geometrythreading}
\end{figure}

\section{Gestione delle Risorse}
La gestione delle risorse è centralizzata nel modulo \texttt{ResourceManager}, che crea, carica e memorizza mesh e
texture. Le factory astratte (\texttt{IResourceFactory}) permettono di implementare varianti specifiche per OpenGL e Vulkan.
Questa progettazione garantisce portabilità e facilita la manutenzione (Fig.\ref{fig:uml-resources}). L’uso di template per
materiali PBR e parametri per ogni oggetto permette di adattare facilmente le risorse alle necessità di rendering.
Ogni risorsa ha un \texttt{ResourceHandle} che garantisce riferimenti unici tramite UID (\emph{Unique Identifier}).
\begin{figure}[htbp]
    \centering
    \includegraphics[width=.6\linewidth]{figures/uml_resources.png}
    \caption{Diagramma UML semplificato della gestione delle risorse.}
    \label{fig:uml-resources}
\end{figure}

%----------------------------------------------------------------------------------------
\chapter{Implementazione}
\label{chap:implementazione}
%----------------------------------------------------------------------------------------
\noindent
In questo capitolo viene descritto come le scelte progettuali del Capitolo~\ref{chap:design} sono state
tradotte in codice. L'obiettivo è fornire una visione chiara dell'architettura interna del motore,
della gestione della scena, delle risorse, dei materiali PBR e dei sistemi di particelle, evidenziando
le differenze tra backend OpenGL e Vulkan e le strategie di ottimizzazione adottate.
Come descritto nei capitoli precedenti, l'engine è stato progettato secondo un'architettura a livelli, dove il core
definisce logiche astratte e ogni backend grafico fornisce una propria implementazione conforme. In questo capitolo si
mostrano frammenti di codice reali che evidenziano come tali scelte siano state applicate concretamente, con particolare
attenzione alla registrazione dei comandi Vulkan, al binding dei materiali PBR e all'uso dell'instancing per il sistema
di particelle. Tutti gli esempi sono estratti direttamente dall'implementazione finale.

\section{Struttura del Codice}
Il motore è organizzato in moduli distinti per separare il codice cross-API dalle implementazioni
specifiche dei renderer. I componenti principali comprendono la gestione della scena, le classi
di risorse e materiali, e i sistemi di rendering. La struttura principale del progetto è la seguente:
\begin{itemize}
    \item \texttt{src/core}: codice indipendente dall'API, inclusi gestione della scena, materiali e componenti;
    \item \texttt{src/gl} e \texttt{src/vk}: implementazioni specifiche dei renderer e costrutti API specific;
    \item \texttt{resources/shaders/gl} e \texttt{resources/shaders/vk}: shader GLSL per ciascun backend;
    \item \texttt{resources/meshes} e \texttt{resources/textures}: asset 3D e texture utilizzate dal motore.
\end{itemize}
La selezione del backend avviene a runtime tramite opzioni di comando, senza alterare il flusso logico
del motore. Questo permette di eseguire test comparativi tra OpenGL e Vulkan utilizzando la stessa
scena e gli stessi asset.

\section{Componenti Principali}
Il cuore del motore è costituito dai seguenti moduli:
\begin{itemize}
    \item \texttt{IRenderer}: interfaccia astratta che definisce le operazioni principali di inizializzazione,
          rendering e pulizia delle risorse.
    \item \texttt{GLRenderer} e \texttt{VulkanRenderer}: implementazioni specifiche per ciascun backend,
          incapsulando le complessità della gestione di buffer, pipeline e sincronizzazione.
    \item \texttt{Scene} e \texttt{Node}: organizzano gli oggetti in una gerarchia e gestiscono le trasformazioni.
    \item \texttt{ResourceManager}: carica, memorizza e gestisce mesh, texture e shader, utilizzando factory
          specifiche per OpenGL e Vulkan.
\end{itemize}
\lstinputlisting[float,floatplacement=htbp,language=C++,label={lst:renderer-factory}]{listings/renderer_factory.cpp}

\section{Gestione della Scena e dei Componenti}
La scena è rappresentata come un grafo di nodi (\texttt{Node}) che possono contenere componenti
come \texttt{TransformComponent}, \texttt{LightComponent} e \texttt{ParticleSystemComponent}.
\lstinputlisting[float,floatplacement=htbp,language=C++,label={lst:scene-management}]{listings/scene_management.cpp}
Ogni nodo mantiene riferimenti ai figli e ai genitori, permettendo la propagazione automatica delle
trasformazioni lungo la gerarchia. Questo approccio consente di gestire complesse relazioni
di parenthood e trasformazioni locali/globali in modo trasparente.
Il ciclo di aggiornamento della scena prevede una traversata gerarchica in cui ciascun nodo
aggiorna i componenti registrati. I \texttt{TransformComponent} calcolano le matrici globali a
partire dalle trasformazioni locali, mentre i componenti di luce aggiornano i dati inviati agli
shader.
I sistemi di particelle calcolano posizione, velocità e altre proprietà fisiche delle
particelle, integrando la simulazione in modo multithreaded quando il backend lo permette.
L'approccio a componenti rende semplice l'estensione della scena con nuovi comportamenti senza
alterare la gerarchia principale e separa chiaramente la logica di aggiornamento dallo stadio
di rendering.
\lstinputlisting[float,floatplacement=htbp,language=C++,label={lst:scene-update}]{listings/scene_update.cpp}

\section{Gestione delle risorse}
La gestione delle risorse è centralizzata nel modulo \texttt{ResourceManager}, che si occupa di
caricare, creare e memorizzare mesh, texture e shader. Ogni risorsa è identificata tramite
\texttt{ResourceHandle} con UID univoci, garantendo riferimenti consistenti senza duplicazioni.
\lstinputlisting[float,floatplacement=htbp,language=C++,label={lst:resource-management}]{listings/resource_management.cpp}
Le factory astratte (\texttt{IResourceFactory}) permettono di istanziare risorse specifiche
per OpenGL o Vulkan. Questo design consente al motore di utilizzare risorse condivise in modo
trasparente tra i backend, mentre le differenze di binding e gestione della memoria GPU
vengono incapsulate nelle implementazioni concrete.

\section{Gestione della Memoria GPU}
Un aspetto centrale dell'implementazione riguarda la gestione della memoria sulla GPU, che rappresenta
una delle differenze più significative tra OpenGL e Vulkan. Nel caso di OpenGL, l'allocazione e la
gestione della memoria sono astratte dal driver, il quale decide in autonomia dove e come collocare i
buffer e le texture. Questa filosofia semplifica notevolmente lo sviluppo, ma rende difficile prevedere
e controllare i costi in termini di prestazioni, specialmente in scenari complessi o multi-threaded.
Vulkan adotta invece un modello esplicito: è responsabilità del programmatore allocare memoria,
gestire i pool e organizzare la vita delle risorse. Per evitare una complessità eccessiva e possibili
errori, è stato utilizzato \emph{Vulkan Memory Allocator (VMA)}, una libreria di allocazione di livello
alto progettata per semplificare il lavoro senza perdere controllo. VMA consente di mantenere un
modello mentalmente chiaro dell'occupazione della memoria, ridurre le frammentazioni e gestire in modo
coerente le operazioni di mapping e copie tra CPU e GPU.
Questa differenza architetturale si riflette in una maggiore prevedibilità e stabilità delle prestazioni
in Vulkan, a fronte di una complessità superiore durante lo sviluppo. L'adozione di un wrapper come VMA
permette comunque di beneficiare del controllo offerto da Vulkan mantenendo una produttività accettabile.

\section{Sistema di Materiali PBR}
Il motore implementa il modello Cook-Torrance per la simulazione fisicamente plausibile della luce.
Ogni materiale è rappresentato come combinazione di \texttt{MaterialTemplate} e
\texttt{MaterialInstance}, separando dati statici da parametri runtime. I template definiscono
shader, textures e valori di default, mentre le istanze permettono variazioni specifiche
per ciascun oggetto.
Ogni materiale PBR fa riferimento a un \texttt{MaterialTemplate} e a una o più
\texttt{MaterialInstance}, consentendo di parametrizzare roughness, metalness e albedo senza
duplicare texture o shader. L'invio dei dati ai GPU avviene tramite uniform buffer in OpenGL
e descriptor set in Vulkan, rispettando le specifiche di ciascun backend.
Durante il \emph{geometry pass}, gli shader scrivono nei G-buffer le informazioni PBR:
albedo, normal encode, roughness, metallic e ambient occlusion. Per ottimizzare la memoria,
le normali sono codificate con oct-encoding nei canali RG, roughness e metallic condividono
canali non utilizzati e l'AO è inserita nell'alpha dell'albedo. Queste scelte riducono
l'occupazione di memoria senza compromettere la qualità visiva.
\lstinputlisting[float,floatplacement=htbp,language=GLSL,label={lst:geometry-pass-snippet}]{listings/geometry_snippet.glsl}
Nel \emph{lighting pass}, i dati del G-buffer vengono combinati con le luci della scena
per calcolare l'illuminazione finale. Il motore supporta luci puntuali, spot e direzionali,
calcolando il contributo speculare e diffuso in base ai parametri PBR. L'approccio deferred
garantisce efficienza anche con numerose sorgenti luminose, evitando ricalcoli geometrici
ridondanti.
Il motore implementa un sistema di materiali PBR basato sul modello Cook-Torrance. Ogni materiale è descritto
tramite \texttt{MaterialTemplate} e \texttt{MaterialInstance}, con parametri fisicamente plausibili come
roughness, metalness e albedo. Le informazioni vengono passate agli shader tramite uniform buffer (OpenGL) o
descriptor set (Vulkan).
La gestione dei materiali consente di applicare facilmente diversi set di texture PBR e modificare i parametri in
tempo reale tramite l'interfaccia grafica del motore.
\lstinputlisting[float,floatplacement=htbp,language=GLSL,label={lst:lighting-pass-snippet}]{listings/lighting_snippet.glsl}

\section{Simulazione di Particelle}
Il motore integra sistemi di particelle configurabili tramite \texttt{ParticleSystemComponent}.
Ogni sistema contiene array di \texttt{ParticleInstanceData} che memorizzano posizione, velocità,
colore e altri attributi. Le particelle sono aggiornate ogni frame tramite integrazione
semi-implicita della fisica, includendo accelerazione e velocità
Per il rendering, le particelle sono disegnate con instancing, riducendo drasticamente il numero
di draw call. Il calcolo multithreaded delle particelle è attivo per entrambi gli API in quanto non influisce
sull'utilizzo dell'API.
Il sistema è progettato per essere flessibile e facilmente estendibile, permettendo di aggiungere
nuove tipologie di particelle o modificare il comportamento fisico senza modifiche invasive
alla struttura principale della scena.

\section{Differenze di Implementazione tra OpenGL e Vulkan}
OpenGL si affida al driver per la gestione della sincronizzazione e dell'invio dei comandi,
mantenendo la pipeline single-thread e riducendo la complessità di implementazione. Vulkan
richiede invece la gestione esplicita di buffer, command pool, descriptor set e sincronizzazione
tramite semafori e fence. Questa differenza influisce sia sulla struttura del codice sia sulla
performance, consentendo a Vulkan di scalare con il numero di core CPU disponibili e
ottimizzare i draw calls e l'uso della memoria GPU.
La pipeline di rendering è quindi progettata per essere modulare: il motore genera comandi
per ciascun backend in modo trasparente, mentre le differenze implementative sono incapsulate
nelle classi \texttt{GLRenderer} e \texttt{VulkanRenderer}. Questo approccio garantisce la
portabilità del codice e la possibilità di confrontare prestazioni e comportamenti dei due
API su scenari identici. \\
La gestione degli shader rappresenta un ulteriore punto di divergenza sostanziale tra OpenGL e Vulkan.
Nel backend OpenGL, gli shader vengono compilati a runtime direttamente dal codice sorgente GLSL,
affidandosi al driver per la traduzione e ottimizzazione del programma. Anche se questo approccio
offre rapidità nello sviluppo e facilita le iterazioni, introduce variabilità tra driver e sistemi
operativi e sposta parte del lavoro di compilazione nel percorso critico di esecuzione.
Vulkan richiede invece che gli shader siano compilati in anticipo nel formato binario
\texttt{SPIR-V}, garantendo che il codice eseguito dal driver sia deterministico e portabile.
Nel progetto, la compilazione avviene tramite gli strumenti ufficiali di Vulkan, consentendo
di catturare errori a livello di build anziché a runtime e migliorando la stabilità complessiva
del sistema. Questa pipeline di compilazione permette inoltre un migliore controllo sull'ottimizzazione
e sull'interfacciamento con descriptor set e layout della pipeline.
\lstinputlisting[float,floatplacement=htbp,label={lst:spv-compilation}]{listings/spv_compilation.cmake}

%----------------------------------------------------------------------------------------
\chapter{Valutazione delle Prestazioni}
\label{chap:valutazione}
%----------------------------------------------------------------------------------------
\noindent
In questo capitolo vengono presentati i risultati sperimentali ottenuti dal motore di rendering sviluppato.
L'obiettivo è confrontare direttamente le performance di OpenGL 4.6 e Vulkan 1.4 in scenari reali, mantenendo
costanti scena, asset e logica applicativa. In questo modo è possibile isolare le differenze imputabili
esclusivamente alle API grafiche. \\
Il test è stato progettato per essere riproducibile e adattabile a diverse configurazioni hardware, così da garantire
una valutazione imparziale. Tutte le misurazioni sono state eseguite utilizzando lo stesso motore, senza modifiche ai
contenuti o al flusso di rendering: l'unica variabile è l'interfaccia grafica selezionata tramite parametro a riga di
comando. L'obiettivo finale è fornire una comparazione verificabile tra le due tecnologie, evidenziandone punti di
forza, limiti e comportamento al variare del carico di lavoro.

\section{Configurazione Sperimentale}
Per la valutazione sono stati considerati scenari multipli, rappresentativi di differenti carichi di lavoro grafico.
Ognuno di essi è caratterizzato da un numero diverso di luci dinamiche e sistemi di particelle, mantenendo costanti
la scena, i materiali PBR e le geometrie. Le scene sono caricate dinamicamente secondo le  configurazioni riportate
nella Tabella~\ref{tab:table-scenes}.
\begin{table}[h!]
\centering
\begin{tabular}{c|c|c|l}
\textbf{Indice} & \textbf{Luci} & \textbf{Sistemi particellari} & \textbf{Descrizione} \\ \hline
0 & 5  & 1 & Scena con basso carico illuminazione \\
1 & 9  & 1 & Scena con illuminazione media \\
2 & 17 & 1 & Scena ad alta complessità luminosa \\
3 & 22 & 0 & Scene con massima intensità luminosa \\
4 & 1  & 2 & Scena focalizzata sulle particelle
\end{tabular}
\caption{Configurazione delle scene utilizzate nei test}
\label{tab:table-scenes}
\end{table}
Le misurazioni raccolte riguardano tempo medio per frame, varianza del frame time, tempo richiesto per ciascuna
render pass, overhead e utilizzo della CPU. Sono stati impiegati strumenti integrati nel motore (\texttt{CPUTimer} e
\texttt{VulkanGPUTimer}) e strumenti esterni di profiling per confermare i risultati. I test sono stati eseguiti su
più architetture hardware riportate nella Tabella~\ref{tab:table-hw}, al fine di valutare scalabilità e stabilità delle prestazioni.
\begin{table}[h!]
\centering
\begin{tabular}{l|l|l|l|l}
   \textbf{ID Test} & \textbf{CPU} & \textbf{GPU} & \textbf{VRAM} & \textbf{RAM} \\ \hline
   A & AMD Ryzen 7 9800X3D & NVIDIA RTX 5080 & 16 GB GDDR7 & 32 GB DDR5 \\
\end{tabular}
\caption{Configurazioni hardware utilizzate nei test}
\label{tab:table-hw}
\end{table}

\section{Risultati}

\section{Discussione}

%----------------------------------------------------------------------------------------
\chapterWithoutNumber{Conclusioni e Sviluppi Futuri}
\label{chap:conclusioni}
%----------------------------------------------------------------------------------------

\paragraph{Sintesi del Lavoro}

\paragraph{Risultati Principali}

\paragraph{Limitazioni del Lavoro}

\paragraph{Sviluppi Futuri}

% End of thesis
\backmatter

\nocite{*}

\bibliographystyle{alpha}
\bibliography{bibliography}

% TODO: Write acknowledgements (optional)
\begin{acknowledgements}
   Optional. Max 1 page.
\end{acknowledgements}

\end{document}
